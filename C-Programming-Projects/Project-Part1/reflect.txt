In this milestone, I learned how to change the data input process by using functions. I used function definition to tell the compiler what to do when a certain function is called. I used self-described names for each parameter to make my code look more friendly and understandable. It was also required to create a new source file called "contacts.c" that included all the function logic/body (header file "contacts.h" must've been included). 

I created new function prototypes for each structure Name , Address , Numbers (EX: void getName(struct Name *name) for Name) that contains information about the name details (initials, full name) and receives a pointer to a Name and performs the action that are given in source code "contacts.c". Function prototypes are declared in "contacts.h" in order to be used in main source code #include "contacts.h". By describing all the steps in "contacts.c" source file and creating a variable type Contact that I called iContact we can just call for the Contact function	using one line of code in the main source code a1ms4.c EX: getName(&iContact.name);   that stored the values for the Name member. Also, we had to use pointers (*) a variable that holds an address. In order to store information for certain struct I used an arrow notation(->) as it looks cleaner which takes form address->member (EX: address->street) that passed the input in struct address to the member called street. Basically, that's all we had to change in this milestone.

Because the struct Name, Address and Numbers are always going together in order not to waste time to declare these 3 structs every time we use them, we created new struct Contact that I called iContact that holds these 3 structs. It also makes it cleaner and easier to read.

It would be poor design to pass a pointer to type Contact as an argument because the way I do it in milestone it looks clear and shows which part it directs to (&iContact.name) for name, otherwise it would look like that (&iContact).